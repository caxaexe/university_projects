# Лабораторная работа №4. Защита конфиденциальных данных

## Требования к лабораторной работе
1. Используйте созданную ранее приложение в 1-й или 3-й лабораторной работе;
2. Выведите на экран содержимое таблицы „user”;
3. Проанализируйте уязвимость – когда пароли хранятся в открытом виде, без применения
хэширования;
4. Объясните преподавателю, как рекомендуется формировать и хранить пароли. Приведите
примеры уязвимых и надежных паролей;
5. Объясните преподавателю, почему хэш-функции MD5, SHA1 уже считаются уязвимыми и
почему. Какие атаки можно выполнить на пароли, если они «захэшированны» с помощью
MD5;
6. Примените рекомендуемые сегодня надежные хэш-функции с «солью» к паролям;
7. Объясните преподавателю, почему вы применили данную функцию, а также
продемонстрируйте, как пароли хранятся в базе данных. Объясните, в чем преимущество
хранения паролей «скрытым» способом. Объясните, какова роль «соли».

## Ход работы


### Cодержимое таблицы „user”
```
mysql -u root -p -D sawm -e "SELECT id, login, password FROM users;"
```
<img width="995" height="314" alt="image" src="https://github.com/user-attachments/assets/038af3c9-5a61-466a-8817-3f4ad3636f14" />

### Анализ уязвимости: пароли в открытом виде
Если пароли хранятся в открытом виде, любой, кто получит доступ к базе данных, сможет их прочитать. Это делает систему очень уязвимой для кражи данных и взлома.

### Как рекомендуется формировать и хранить пароли. Примеры.
Пароли нужно хранить в зашифрованном (хэшированном) виде с использованием «соли».
- Уязвимые: 12345, password, qwerty, admin.
- Надёжные: P@ssw0rd!94, r9#HkT2b!, Moldova2025!x.
Надёжные пароли должны содержать буквы, цифры и специальные символы.

### Почему MD5 и SHA1 считаются уязвимыми. Какие атаки возможны.
MD5 и SHA1 можно «взломать» при помощи готовых таблиц (rainbow tables) или подбора (brute force), так как они слишком быстрые и устарели. Хэш-функции могут давать одинаковый результат для разных паролей — это называется коллизией.

### Применение хэша с "солью"
```php
<?php
session_start();

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    header("Location: ../public/login.php");
    exit();
}

$login = trim($_POST['login'] ?? '');
$password = $_POST['password'] ?? '';
$error = '';

if ($login === '' || $password === '') {
    $error = "Введите логин и пароль.";
} else {
    $conn = new mysqli("localhost", "root", "", "sawm");
    if ($conn->connect_error) {
        die("Ошибка подключения: " . $conn->connect_error);
    }

    $stmt = $conn->prepare("SELECT id, login, password FROM users WHERE login = ?");
    $stmt->bind_param("s", $login);
    $stmt->execute();
    $result = $stmt->get_result();

    if ($result && $result->num_rows > 0) {
        $user = $result->fetch_assoc();
        $hash = $user['password'];
        $ok = false;

        // проверка является ли пароль хэшем
        if (str_starts_with($hash, '$argon2id$') || str_starts_with($hash, '$2y$')) {

            $ok = password_verify($password, $hash);
        } else {
            if ($password === $hash) {
                $ok = true;
                $newHash = password_hash($password, PASSWORD_ARGON2ID);
                $upd = $conn->prepare("UPDATE users SET password = ? WHERE id = ?");
                $upd->bind_param("si", $newHash, $user['id']);
                $upd->execute();
                $upd->close();
            }
        }

        if ($ok) {
            if (mb_strtolower($user['login']) === 'admin') {
                $_SESSION['admin'] = $user['login'];
                header("Location: ../public/admin.php");
            } else {
                $_SESSION['user'] = $user['login'];
                header("Location: ../public/user.php");
            }
            exit();
        } else {
            $error = "Неверный логин или пароль.";
        }
    } else {
        $error = "Пользователь не найден.";
    }

    $stmt->close();
    $conn->close();
}
?>
```

### Объяснялки
Хранение хэшей вместо паролей защищает пользователей даже при утечке базы данных — злоумышленник не узнает настоящий пароль. Соль — это случайная строка, которую добавляют к паролю перед хэшированием, чтобы сделать каждый хэш уникальным.  
  
password_hash() — хэширует пароль.
- Принимает обычный текстовый пароль и алгоритм (например, PASSWORD_ARGON2I).
- Генерирует случайную соль автоматически.
- Возвращает готовую строку-хэш, которую можно хранить в базе.
  
password_verify() — проверяет пароль.
- Принимает введённый пользователем пароль и хэш из базы.
- Сам извлекает соль и параметры из хэша.
- Возвращает true, если пароль совпадает, иначе false.
